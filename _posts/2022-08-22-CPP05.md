---
layout: post
author: Younji Kim
---
CPP05에 관한 정리글. 예외처리(exception)에 대해 배우고 try~catch 문을 연습한다.

## Table of contents
- [Table of contents](#table-of-contents)
- [예외 처리란?](#예외-처리란?)
- [예외 클래스](#예외-클래스)
- [예외처리 순서](#예외처리-순서)

## [예외 처리란?](#예외-처리란?)
예외(exception)는 프로그램의 실행 동안에 발생할 수 있는 비정상적인 상황을 말한다. 배열의 인덱스에 접근했는데, 그 인덱스 위치에 요소가 존재하지 않을 때와 같은 상황을 예외적인 상황이라 한다. 프로그램에서는 이와 같은 예외 상황을 처리하도록 코드를 작성해야 한다. <br>
예외 처리(exception-handling)를 하는 가장 간단한 방법은 if문으로 처리하는 것이다. 그러나 우리는 예외 상황을 나타니는 exception 객체를 통해 더욱 명시적으로 예외를 처리할 것이다. 예외를 생성(create), 전달(throw), 받기(catch), 처리(handle) 과정을 통해 핸들링해보자.

```
try
{
	if (number2 == 0)
		throw number1;
}
catch (int ex) {
	std::cout << "Exception : " << ex << "cannot be devided by zero" << std::endl;
}
```
위 코드가 예외처리의 예시이다.
* try 블록 : 일반적인 상황에서 실행되는 코드 모음이다.
* catch 블록 : 예외를 인자로 받아 처리하는 코드 부분이다.
* throw 문 : `throw number1;`에서 number1을 예외(exception)라고 한다. throw 문의 실행을 예외 전달(throwing an exception)이라고 하며, 어떤 유형의 값으로도 전달할 수 있다. 위 코드에서는 int형이다. 예외가 전달될 때, 일반적인 실행 흐름은 중단 된다. '예외 전달'은 예외를 발생한 곳에서 다른 곳으로 전달하는 것이다. 전달된 예외는 catch문에서 받아 처리하는 것이다.
요악하면 다음과 같다.
```
try {
	try할 코드;
	throw 문으로 예외 전달;
	try할 다른 코드;
}
catch (type ex)
{
	예외를 핸들링하는 코드;
}
```

### 예외 처리의 장점
예외 처리의 기본 개념은 오류 검출(호출된 함수에서 수행)과 오류 처리(호출하는 함수에서 수행)를 서로 분리하는 것이다. <br>
예외 처리는 함수가 호출자에게 예외를 전달할 수 있도록 해준다. 이런 기능이 없다면 함수가 직접 예외처리를 하거나 프로그램을 종료해야 한다. 오류가 발생한 경우 호출된 함수가 무엇을 해야 할 지 모르는 경우가 종종 있는데, 이는 라이브러리 함수의 경우일반적으로 발생한다. 라이브러리 함수는 오류를 감지할 수 는 있지만 오류가 발생했을 때에 호출자만이 무엇을 해야 할 지를 알고 있다.

## [예외 클래스](#예외-클래스)
예외 객체를 생성하고 예외를 전달하기 위해 C++ 표준 예외 클래스를 사용할 수 있다.<br>
위의 코드에서 catch 블록의 매개변수는 int형이었다. catch 블록에 전달하고자 하는 데이터의 양이 많아질수록 클래스 유형이 더 유용할 수가 있다. C++은 예외 객체를 생성하기 위해 사용할 수 있는 많은 표준 클래스들을 제공한다. 
그 중 루트 클래스는 <exception> 헤더에 정의되어 있는 exception이다. 이는 예외 객체의 오류 메시지를 반환하는 가상 함수 what()을 포함하고 있다. <br>
값을 저장하기에는 너무 큰 경우 같은 산술 오버플로가 났을 때는 overflow_error 클래스, 런타임 에러가 났을 때 쓰는 runtime_error 클래스 등 다양하다.<br>
물론 사용자가 직접 에러를 처리할 수도 있다. 
*생성자에서 예외를 던지게 되면 소멸자가 호출되지 않기 때문에 catch에서 잘 해제 시켜주어야 한다.*

## [예외처리 순서](#예외처리-순서)
catch문의 경우 가장 먼저 대입될 수 있는 객체를 받는다. 기본 클래스의 객체 -> 파생 클래스의 객체 순으로 catch문을 작성하면, 기본 클래스 포인터에 연결된 파생 클래스 포인터의 경우 기본 클래스의 catch문으로 들어가게 된다.
때문에 catch문은 파생클래스, 기본클래스 순으로 catch 할 수 있도록 작성하는 것이 좋다.